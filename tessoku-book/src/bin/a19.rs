use proconio::input;
fn main() {
    input! {
        n: usize,
        W: usize,
        wv: [(usize,usize); n]
    };

    // 重さW+1個の配列がn+1個ある
    // n回回して、一つ前のvを入れた時、入れなかった時の値が、dp[i][j]に入る
    // dp[i][j]に入っているのはvの合計値で、
    // iはn個のアイテムの走査に、jは、現在計算済みの重さを表現している
    // 現在の重さの合計値がindexとして表現されるところがちょっと難しい
    let mut dp = vec![vec![0; W + 1]; n + 1];
    dp[0][0] = 0;
    for (i, (w, v)) in wv.iter().enumerate() {
        for j in 0..=W {
            if j < *w {
                // こっちは重さwがoverしている場合。その場合は一つ前の配列の値をそのまま採用する
                dp[i + 1][j] = dp[i][j];
            } else {
                // wが入る場合、最大値を採用したい。そうすると一つ前の値dp[i-1]の配列のjにある値と、jから現在の重さを足してv足したもののうち、大きい方を採用する
                // 後者はWからwを引いてvを加算するという計算そのまんま
                dp[i + 1][j] = dp[i][j].max(dp[i][j - w] + v);
            }
        }
    }
    // 最後のアイテムまで走査した後、最後の配列のいずれか最も大きい値が答え(重さがピッタリ使い切られるとは限らないので、dp[n][W]にあるとは限らない)
    println!("{}", dp[n].iter().max().unwrap());
}
